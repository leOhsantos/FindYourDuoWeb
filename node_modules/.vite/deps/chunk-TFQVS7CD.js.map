{
  "version": 3,
  "sources": ["../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/index.ts", "../../@radix-ui/react-use-previous/dist/packages/react/use-previous/src/usePrevious.tsx", "../../@radix-ui/react-label/dist/packages/react/label/src/index.ts", "../../@radix-ui/react-label/dist/packages/react/label/src/Label.tsx"],
  "sourcesContent": ["export { usePrevious } from './usePrevious';\n", "import * as React from 'react';\n\nfunction usePrevious<T>(value: T) {\n  const ref = React.useRef({ value, previous: value });\n\n  // We compare values before making an update to ensure that\n  // a change has been made. This ensures the previous value is\n  // persisted correctly between renders.\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\n\nexport { usePrevious };\n", "export {\n  Label,\n  //\n  Root,\n  //\n  useLabelContext,\n} from './Label';\nexport type { LabelProps } from './Label';\n", "import * as React from 'react';\nimport { createContext } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\n/* -------------------------------------------------------------------------------------------------\n * Label\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Label';\n\ntype LabelContextValue = { id?: string; controlRef: React.MutableRefObject<HTMLElement | null> };\nconst [LabelProvider, useLabelContextImpl] = createContext<LabelContextValue>(NAME, {\n  id: undefined,\n  controlRef: { current: null },\n});\n\ntype LabelElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface LabelProps extends PrimitiveSpanProps {\n  htmlFor?: string;\n}\n\nconst Label = React.forwardRef<LabelElement, LabelProps>((props, forwardedRef) => {\n  const { htmlFor, id: idProp, ...labelProps } = props;\n  const controlRef = React.useRef<HTMLElement | null>(null);\n  const ref = React.useRef<HTMLSpanElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const id = useId(idProp);\n\n  React.useEffect(() => {\n    if (htmlFor) {\n      const element = document.getElementById(htmlFor);\n      const label = ref.current;\n      if (label && element) {\n        const getAriaLabel = () => element.getAttribute('aria-labelledby');\n        const ariaLabelledBy = [id, getAriaLabel()].filter(Boolean).join(' ');\n        element.setAttribute('aria-labelledby', ariaLabelledBy);\n        controlRef.current = element;\n        return () => {\n          /**\n           * We get the latest attribute value because at the time that this cleanup fires,\n           * the values from the closure may have changed.\n           */\n          const ariaLabelledBy = getAriaLabel()?.replace(id, '');\n          if (ariaLabelledBy === '') {\n            element.removeAttribute('aria-labelledby');\n          } else if (ariaLabelledBy) {\n            element.setAttribute('aria-labelledby', ariaLabelledBy);\n          }\n        };\n      }\n    }\n  }, [id, htmlFor]);\n\n  return (\n    <LabelProvider id={id} controlRef={controlRef}>\n      <Primitive.span\n        role=\"label\"\n        id={id}\n        {...labelProps}\n        ref={composedRefs}\n        onMouseDown={(event) => {\n          props.onMouseDown?.(event);\n          // prevent text selection when double clicking label\n          if (!event.defaultPrevented && event.detail > 1) event.preventDefault();\n        }}\n        onClick={(event) => {\n          props.onClick?.(event);\n          if (!controlRef.current || event.defaultPrevented) return;\n          const isClickingControl = controlRef.current.contains(event.target as Node);\n          // Ensure event was generated by a user action\n          // https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted\n          const isUserClick = event.isTrusted === true;\n          /**\n           * When a label is wrapped around the control it labels, we trigger the appropriate events\n           * on the control when the label is clicked. We do nothing if the user is already clicking the\n           * control inside the label.\n           */\n          if (!isClickingControl && isUserClick) {\n            controlRef.current.click();\n            controlRef.current.focus();\n          }\n        }}\n      />\n    </LabelProvider>\n  );\n});\n\nLabel.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst useLabelContext = (element?: HTMLElement | null) => {\n  const context = useLabelContextImpl('LabelConsumer');\n  const { controlRef } = context;\n\n  React.useEffect(() => {\n    if (element) controlRef.current = element;\n  }, [element, controlRef]);\n\n  return context.id;\n};\n\nconst Root = Label;\n\nexport {\n  Label,\n  //\n  Root,\n  //\n  useLabelContext,\n};\nexport type { LabelProps };\n"],
  "mappings": ";;;;;;;;;;;;;;;;ACEA,SAASA,0CAAeC,OAAU;AAChC,QAAMC,UAAMC,aAAAA,QAAa;IAH3B;IAGoCC,UAAUH;GAAhC;AAKZ,aAAOE,aAAAA,SAAc,MAAM;AACzB,QAAID,IAAIG,QAAQJ,UAAUA,OAAO;AAC/BC,UAAIG,QAAQD,WAAWF,IAAIG,QAAQJ;AACnCC,UAAIG,QAAQJ,QAAQA;;AAEtB,WAAOC,IAAIG,QAAQD;KAClB;IAACH;GANG;;;;;AEIT,IAAMK,6BAAO;AAGb,IAAM,CAACC,qCAAeC,yCAAhB,IAAuCC,0CAAiCH,4BAAM;EAClFI,IAAIC;EACJC,YAAY;IAAEC,SAAS;;CAFiC;AAW1D,IAAMC,gDAAQC,cAAAA,YAA2C,CAACC,OAAOC,iBAAiB;AAChF,QAAM,EAAA,SAAWP,IAAIQ,WAAWC,WAAH,IAAkBH;AAC/C,QAAMJ,iBAAaG,cAAAA,QAAiC,IAAjC;AACnB,QAAMK,UAAML,cAAAA,QAA8B,IAA9B;AACZ,QAAMM,eAAeC,0CAAgBL,cAAcG,GAAf;AACpC,QAAMV,KAAKa,0CAAML,MAAD;AAEhBH,oBAAAA,WAAgB,MAAM;AACpB,QAAIS,SAAS;AACX,YAAMC,UAAUC,SAASC,eAAeH,OAAxB;AAChB,YAAMI,QAAQR,IAAIP;AAClB,UAAIe,SAASH,SAAS;AACpB,cAAMI,eAAe,MAAMJ,QAAQK,aAAa,iBAArB;AAC3B,cAAMC,kBAAiB;UAACrB;UAAImB,aAAY;UAAIG,OAAOC,OAA5B,EAAqCC,KAAK,GAA1C;AACvBT,gBAAQU,aAAa,mBAAmBJ,eAAxC;AACAnB,mBAAWC,UAAUY;AACrB,eAAO,MAAM;AAAA,cAAA;AAKX,gBAAMM,kBAAc,gBAAGF,aAAY,OAAf,QAAA,kBAAA,SAAA,SAAG,cAAgBO,QAAQ1B,IAAI,EAA5B;AACvB,cAAIqB,mBAAmB;AACrBN,oBAAQY,gBAAgB,iBAAxB;mBACSN;AACTN,oBAAQU,aAAa,mBAAmBJ,cAAxC;;;;KAKP;IAACrB;IAAIc;GAvBR;AAyBA,aACE,cAAAc,eAAC,qCADH;IACiB;IAAQ;SACrB,cAAAA,eAAC,0CAAU,MADb,SAAA;IAEI,MAAK;IACL;KACInB,YAHN;IAIE,KAAKE;IACL,aAAckB,CAAAA,UAAU;AAAA,UAAA;AACtB,OAAA,qBAAAvB,MAAMwB,iBAAN,QAAA,uBAAA,UAAA,mBAAA,KAAAxB,OAAoBuB,KAAf;AAEL,UAAI,CAACA,MAAME,oBAAoBF,MAAMG,SAAS;AAAGH,cAAMI,eAAN;;IAEnD,SAAUJ,CAAAA,UAAU;AAAA,UAAA;AAClB,OAAA,iBAAAvB,MAAM4B,aAAN,QAAA,mBAAA,UAAA,eAAA,KAAA5B,OAAgBuB,KAAX;AACL,UAAI,CAAC3B,WAAWC,WAAW0B,MAAME;AAAkB;AACnD,YAAMI,oBAAoBjC,WAAWC,QAAQiC,SAASP,MAAMQ,MAAlC;AAG1B,YAAMC,cAAcT,MAAMU,cAAc;AAMxC,UAAI,CAACJ,qBAAqBG,aAAa;AACrCpC,mBAAWC,QAAQqC,MAAnB;AACAtC,mBAAWC,QAAQsC,MAAnB;;;GAxBN,CAAA,CADF;CAjCU;AAkEd,OAAA,OAAA,2CAAA;EAAA,aAAA;CAAA;AAIA,IAAMC,4CAAmB3B,CAAAA,YAAiC;AACxD,QAAM4B,UAAU7C,0CAAoB,eAAD;AACnC,QAAM,EAAA,WAAEI,IAAeyC;AAEvBtC,oBAAAA,WAAgB,MAAM;AACpB,QAAIU;AAASb,iBAAWC,UAAUY;KACjC;IAACA;IAASb;GAFb;AAIA,SAAOyC,QAAQ3C;;",
  "names": ["usePrevious", "value", "ref", "React", "previous", "current", "NAME", "LabelProvider", "useLabelContextImpl", "createContext", "id", "undefined", "controlRef", "current", "Label", "React", "props", "forwardedRef", "idProp", "labelProps", "ref", "composedRefs", "useComposedRefs", "useId", "htmlFor", "element", "document", "getElementById", "label", "getAriaLabel", "getAttribute", "ariaLabelledBy", "filter", "Boolean", "join", "setAttribute", "replace", "removeAttribute", "$7V4JZ$createElement", "event", "onMouseDown", "defaultPrevented", "detail", "preventDefault", "onClick", "isClickingControl", "contains", "target", "isUserClick", "isTrusted", "click", "focus", "useLabelContext", "context"]
}
